import re


code = ("function x = (y+z) ^s {"+
  "return x"+
"} function test(as,dddd){return x}")

class Lexer:

	token_syntax = {
	            'var': 'VAR',
	            'function':'FUNCTION',
	            'return': 'RETURN',
	            'print': 'PRINT',
	            '+': 'ADD',
	            '=': 'ASSIGN',
	            '-': 'SUB',
	            '*': 'MULT',
	            '/': 'DIV',
	            '^': 'EXP',
	            '(': 'LPAREN',
	            ')': 'RPAREN',
	            '{': 'LBRACE',
	            '}': 'RBRACE',
	            ',': 'COMMA',
	            ':': 'COLON',
         }


	def __init__(self, code):
		self.input = code
		self.raw_tokens = self.split_code()
		self.token_syntax, self.pair = self.tokenize(self.raw_tokens)

	def split_code(self):
		input_code = self.input
		chars = "+=-*/^(){},:"
		for c in chars:
			if c in input_code:
				input_code = input_code.replace(c, " {} ".format(c))
		input_code = re.sub(' +',' ',input_code)
		input_code = input_code.strip().split(" ")
		return input_code

	def tokenize(self, splited_code):
		code_tokened = []
		token_lexeme_pair = []

		for character in splited_code:
			if character.lstrip('-').replace('.','',1).isdigit():
				code_tokened.append("NUMBER:{}".format(character))
				token_lexeme_pair.append("NUMBER:{}".format(character))
			elif (bool(re.match("(^([^-_].*[^-_])?$)|(^[a-zA-Z]$)", character))
				and character not in self.token_syntax):
				code_tokened.append("IDENT:{}".format(character))
				token_lexeme_pair.append("IDENT:{}".format(character))
			elif character in self.token_syntax:
				code_tokened.append(self.token_syntax[character])
				token_lexeme_pair.append("{}:{}".format(self.token_syntax[character], character))
			else:
				raise ValueError("Syntax Error")

		return code_tokened, token_lexeme_pair


	def CheckFunctionIsValid(self, syn, token, badtokens, validfunctions):
		validfunctions = validfunctions
		FunctionParameters = []
		commas = 0

		try:
			functionName = badtokens[token+1]
			if badtokens[token+2] != "(":
				raise ValueError(syn + "A function must have correct parenthesis")
			else:
				for findbrackets in range(token+3, len(badtokens)):
					if bool(re.match("(^([^-_].*[^-_])?$)|(^[a-zA-Z]$)", badtokens[findbrackets])):
						print "parameter ", badtokens[findbrackets]
						FunctionParameters.append(badtokens[findbrackets])
					if badtokens[findbrackets] == ",":
						print "comma ", badtokens[findbrackets]
						commas += 1
					if badtokens[findbrackets] == "(":
						raise ValueError(syn + "Error reading parenthesis")
					if badtokens[findbrackets] == ")":
						print "found )"
						if (commas + 1) != len(FunctionParameters):
							raise ValueError(syn + "Error with parameter formation")
						try:
							badtokens[findbrackets+1]
						except IndexError:
							raise IndexError(syn + "Missing the function body")
						else:
							if badtokens[findbrackets+1] == "{":
								print "found {"
								containsReturn = False
								containsClosingBracket = False
								newParameters = []
								ReturnLocation = 0


								for closebrackets in range(findbrackets+1, len(badtokens)):
									print "closebrackets loop :", badtokens[closebrackets]
									if (bool(re.match("(^([^-_].*[^-_])?$)|(^[a-zA-Z]$)", badtokens[closebrackets]))
										and badtokens[closebrackets-1].lower() == "var"):
											newParameters.append(badtokens[closebrackets])
									if badtokens[closebrackets].lower() == "function":
										validfunctions = self.CheckFunctionIsValid(self, syn, token, badtokens, validfunctions)
									if badtokens[closebrackets].lower() == "print":
										print "stuff"
									if badtokens[closebrackets].lower() == "return":
										containsReturn = True
										ReturnLocation = closebrackets
									if badtokens[closebrackets].lower() == "}" and containsReturn:
										containsClosingBracket = True


										arithmetic_check = ["+","=","-","*","/","^"]
										statement_check = ["var","function","return", "print"]
										if closebrackets-ReturnLocation+1 == 0:
												raise ValueError(syn + "There is no ParameterList to return")
										if closebrackets-ReturnLocation+1 == 1:
											if (badtokens[ReturnLocation+1] not in newParameters
												and badtokens[ReturnLocation+1] not in ParameterList
												and badtokens[ReturnLocation+1].lstrip('-').replace('.','',1).isdigit() == False):
												raise ValueError(syn + "Return parameter must be valid")

										for parameters in range(ReturnLocation+1, closebrackets):
											if (badtokens[parameters] not in FunctionParameters
												and badtokens[parameters] not in newParameters
												and badtokens[parameters].lstrip('-').replace('.','',1).isdigit() == False
												and badtokens[parameters] not in arithmetic_check):
												raise ValueError(syn + "parameter not recognized")
											if badtokens[parameters] in statement_check:
												raise ValueError(syn + "Can't return a statement")
											if badtokens[parameters] in arithmetic_check:
												try:
													badtokens[parameters-1]
													badtokens[parameters+1]
												except IndexError:
													raise IndexError(syn + "Arithmetic expression must literal before and after")
												else:
													if badtokens[parameters-1].
											else:
												if badtokens[parameters+1] not in arithmetic_check



										validfunctions[functionName] = len(FunctionParameters)
										break

								if containsReturn == False:
									raise ValueError(syn + "A function must return a parameter or parameter list")
								if containsClosingBracket == False:
									raise ValueError(syn + "The function is missing a closing bracket")
							else:
								raise ValueError(syn + "Missing the function body")
							break
		except IndexError:
			raise IndexError(syn + "Invalid Function")
		else:
			return validfunctions

		def IsParameterCorrect(self, FunctionParameters, newParameters, syn, token):
			ValidParameters = FunctionParameters.extend(newParameters)
			arithmetic_check = ["+","=","-","*","/","^"]
			statement_check = ["var","function","return", "print"]
			if (token not in arithmetic_check
				and token not in ValidParameters
				and (badtokens[parameters].lstrip('-').replace('.','',1).isdigit() == False


	def __repr__(self):
			return " ".join(self.token_syntax)


test = Lexer(code)
print test.raw_tokens
